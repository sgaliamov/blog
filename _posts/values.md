---
title: Values
categories: ["general", "programming"]
created: 2021-06-29
date: 2021-05-02
layout: post
---

Developers spend most of their time focusing on the technical aspects of programming.
We like best practices, principles, design patterns, and anything that helps us create good software.
And this is good.

But there are other important things that are perhaps even more important than this.
Some people may refer to this as "Soft skills".
I'd like to find another name for this, because this things are not "soft" and not quite skills.

I would say that these are the Values.
A denial of these values will lead to the collapse of any project,
even if it follows the most perfect best practices and uses the most modern tools.
And the opposite is true.
A deep acceptance of these values can even compensate for the lack of technical skills.

## Simplicity

I put this first because it matters.
It’s very easy to create a complex solution.
You don’t need to be a senior or an architect to make a really sophisticated thing.
Literally anyone can do it, and then think that he did something cool just because it looks complex.
But maintaining it isn't cool.

There is no honor in producing complexity.
Designing a simple, easy-to-maintain solution that even a junior can support is very challenging.
Principles like SOLID, “Composition over Inheritance”, KISS, YAGNI help us to fight with complexity and entropy,
but they won't work if a developer thinks that creating a big multilevel class hierarchy is what programming about.

> Another thing that kills simplicity is an attempt to create universal framework or approach that solves all problems.
> You can heard - "there is no sliver bullet".

## Moderation & Maturity

Simplicity is the result of maturity and experience.
Following best practices is a good thing.
But very often developers jump onto new technologies, patterns and methodologies just for the sake of their use and not for the solving problems.
As result, we often can see projects in a poor condition where multiple different architectures are applied,
and non of them is brought to a logical result.

There so much interesting things in software engineering, and it’s hard to blame developers that they want to try everything.
In addition we all want to be up to date to stay competitive on the market.
To be professional and efficient we should always “sharpen the saw”.

The only problem is that developers are too often carelessly experimenting in production code with things they don't fully understand.
Others have to pay for this unsuccessful experiments with the employer's money or the time of other developers.
We live in a very unfair world where maintenance of solutions are less respected and less paid than building new green field projects,
even if that maintenance actually makes a profit for the companies.

Doing own pet projects is the great way to experiment and to learn without breaking production code and making others live harder.
In my opinion, a developer cannot be considered a good developer if he is not engaged in his own projects in his spare time.
And it must be some kind real solution, not just "Hello world!" samples,
otherwise he will not know what the delivery actually is, and what really matters.

## Pragmatism & Result

Only the delivery is matters.
No one need coding for sake of coding.
If you are not scientist or artist of course.
And we are not.
We are engineers.
We write programs to make others live better and easier.

If we don't offer the real solution to the real problem, we play toys.
And it's probably great, especially if you paid for it.
But at some point the games end.
If you are not ready for this, you loose.

For example, "100% code coverage" sounds good.
Nobody argues with this.
Even saying something against it is dangerous.
Like many “best practices,” this has an almost religious status.
This is sad that cargo cult is a very common occurrence in software development.
Just think, how much other cool thing you could build instead of writing tests?

I'm not saying that we should not write tests at all.
What I am saying is that we have to do just enough to be confident when deploying to a production environment.
A good programmer is a lazy programmer.

Perfectionism is a great quality of a developer, I believe.
But but everything has limits and any investment should pay off over time.
If you can't apply the skills you've acquired through endless refactorings and tunings, you've wasted your time.
And live as a result.
Nobody cares about this.
"Quality in a service or product is not what you put into it. It is what the client or customer gets out of it." - Peter Drucker.

## Passion & Patience

People who care about their work tend to provide better results.
Passion is a driver that pushes you beyond the boundaries.

But passion has a dark side.
Sometimes people go too far and can’t handle emotions.
People often talk about the giving feedback skill, but for some reason, they ignore the receiving feedback skill.
I think, ability adequately receiving any feedback is more important skill.
There is a nasty trick.
If someone tells you that he knows better, don’t argue, just do what he says.
This is the way to share responsibility for the case if something will go wrong.
And it will.
We all know that developers always miss with their estimations.
So, failure won't be yours alone.
And opposite. If you know that someone is doing wrong, and doesn’t want to listen.
Don’t worry. Let people make their own mistakes.
At least they will learn something. If you were right, they will listen eventually.
Be passionate and patient.

## Supportiveness

The biggest problem in programming is people.
They are lazy, not disciplined and always make mistakes.
If we could eliminate this component from the equation, things would be much easier.
But we can't.
Fortunately or not.

We work in teams to achieve a bigger result than we can accomplish alone.
This is why we should think more about the value we create than about our ego.
We should think more how to help our teammates than about current needs or interests.

## Ownership & Responsibility

We all know that code ownership is a bad practice.
Saying something for ownership is almost like saying that 100% code coverage is not a goal.
People can start throwing in you pissed off rags.

But what I see in the really.
You cannot get responsibility for something if you cannot make decisions about it.
How can you prevent a failure or build something outstanding if you cannot control the development process?

Shared responsibility is no responsibility.
As result, developers often focus only on small part of the system and don't care about anything else.

Sure, ownership brings responsibility.
If you are not ready for this, you should no take it.
But when you take it, you are limited only with your imagination and level of your energy.
Don't forget about the budget, of course, unless you own it.

## Other things

There are lot of other important things like `Professionalism` and  `Learning`.
I am not underestimating their importance.
They are very significant, and perhaps `Learning` is my favorite on this list.
They are good topics for other discussions, but I stop here so as not to make this post too long to read.

