запускать алгоритм на большом тексте очень долго, по-этому я сделал дополнительную утилиту, которая перетасовками пытается найти более короткую версию текста, но имеющую теже статистические характеристики.

// 0. load all texts.
// 1. shuffle current set.
// 1.1. if shuffeled 10 times, save text and exit.
// 2. split on 2 parts.
// 3. calculate score for both parts.
// 4. if both bad, go to 1.
// 5. get best part.
// 6. go to 2.

алгоритм очень чуствителен к тексту который используется для бенчмарка.
но все же вырисовываются общие закономерности.
в целом, разница между различными вариантами незначительная, по-этому нужно просто выбрать то что выглядит логично.

попытка найти идеальный лайаут всегда обречена на провал, так как все очень сильно зависит от текстов, и выбранных предпочтениях.

даже можно найти требования при которых qwerty будет выигрывать.
нарпимер это может быть эффективное использование шоткатов.

# findings

1. лучше рандомизировать количество мутаций.\
   это позволи перепрыгивать через локальные минимумы и наоборот двигаться более мелкими шагами.
1. нужно не давать лушему выводку заполонить потомками всю популяцию.\
   нужена граница за которую они не могут выходить.\
   это позволит другим линиям выжить и порадить лучший результат.\
   это позволяет выйти из локального минимума.
